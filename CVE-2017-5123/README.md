# CVE-2017-5123

**CVE-2017-5123** is a vulnerability in the waitid syscall implementation which allows writes (limited writes only 0 can be written anywhere in memory) to memory address specified by user without checking if they are kernel addresses or userland addresses.


# Understanding the Vulnerability.

File : `kernel/exit.c`

```C
SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
	struct waitid_info info = {.status = 0};
	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
	int signo = 0;

	if (err > 0) {
		signo = SIGCHLD;
		err = 0;
		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
			return -EFAULT;
	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);             /*  All the unsafe_put_user() calls should tingle your spidy senses  */ 
	unsafe_put_user(0, &infop->si_errno, Efault);                            
	unsafe_put_user(info.cause, &infop->si_code, Efault);         
	unsafe_put_user(info.pid, &infop->si_pid, Efault);             
	unsafe_put_user(info.uid, &infop->si_uid, Efault);              
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;                                                         
Efault:
	user_access_end();
	return -EFAULT;
}
```

lets look at the unsafe_put_user() function  

File: `include/linux/uaccess.h`

```C

/*
 * The "unsafe" user accesses aren't really "unsafe", but the naming
 * is a big fat warning: you have to not only do the access_ok()
 * checking before using them, but you have to surround them with the
 * user_access_begin/end() pair.
 */
#define user_access_begin()	__uaccess_begin()
#define user_access_end()	__uaccess_end()

#define unsafe_put_user(x, ptr, err_label)					\
do {										\
	int __pu_err;								\
	__typeof__(*(ptr)) __pu_val = (x);					\
	__put_user_size(__pu_val, (ptr), sizeof(*(ptr)), __pu_err, -EFAULT);	\
	if (unlikely(__pu_err)) goto err_label;					\
} while (0)

#define unsafe_get_user(x, ptr, err_label)					\
do {										\
	int __gu_err;								\
	__inttype(*(ptr)) __gu_val;						\
	__get_user_size(__gu_val, (ptr), sizeof(*(ptr)), __gu_err, -EFAULT);	\
	(x) = (__force __typeof__(*(ptr)))__gu_val;				\
	if (unlikely(__gu_err)) goto err_label;					\
} while (0)

#endif /* _ASM_X86_UACCESS_H */ss
```
unsafe_put_user() macro will just write a value to the pointer specified by ptr


Oh look! Somebody wrote a comment it says that we need to surround unsafe_put_user() with user_access_begin/end() pair and also perform access_ok() lets take a look at these functions .

```C
#define __uaccess_begin() stac()
#define __uaccess_end()   clac()
```
the __uaccess_begin() and __uaccess_end() are just wrapper macros for stac and clac assembly instructions

stac:`Sets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register.`

[more about stac instrcution :](https://www.felixcloutier.com/x86/stac)

clac:`Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.`

[more about clac instruction :](https://www.felixcloutier.com/x86/clac)

__uaccess_begin() and __uaccess_end() basically disable and enable SMAP for userland access respectively.


```C
/**
 * access_ok: - Checks if a user space pointer is valid
 .
 .
 .
 **/
    #define access_ok(type, addr, size)					\
({									\
	WARN_ON_IN_IRQ();						\
	likely(!__range_not_ok(addr, size, user_addr_max()));		\
})

```
the access_ok() macro just checks if a pointer is a valid userland pointer and EFAULTs if otherwise.

[//]: # (todo: add explainations for compiler optimization functions like likey() and unlikely .... also explain SMAP ....)
